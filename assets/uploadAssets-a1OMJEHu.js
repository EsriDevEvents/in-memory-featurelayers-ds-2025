import{V as y,U as f,X as u,A as G,H as J,d_ as V,Z as S,D as W,$ as X,hJ as Z,F as K,a5 as Q,G as Y}from"./index-Dv-JqQDv.js";import{h as ss,N as es,i as U,o as $,A as ts}from"./External-DIu21-ag.js";import{r as as,n as ns,a as os,d as rs,c as x,l as is,t as cs,u as ls,p as us}from"./uploadAssetErrors-CBvwS73J.js";import{i as g,h as ps,e as b,m as ms,a as fs}from"./progressUtils-B5fuZL_N.js";const I=1e6,N=20*I,ds=2e9,ys=3;async function gs({data:e,name:t,description:s},a,n){let o=null;try{const r=y(a,"uploads"),i=y(r,"info"),{data:c}=await f(i,{query:{f:"json"},responseType:"json"});u(n);const p=G(a),l=c.maxUploadFileSize*I,d=p?ds:l,A=p?Math.min(N,l):N;if(e.size>d)throw new Error("Data too large");const R=y(r,"register"),{data:j}=await f(R,{query:{f:"json",itemName:ws(t),description:s},responseType:"json",method:"post"});if(u(n),!j.success)throw new Error("Registration failed");const{itemID:k}=j.item;o=y(r,k);const B=y(o,"uploadPart"),F=Math.ceil(e.size/A),w=new Array;for(let m=0;m<F;++m)w.push(e.slice(m*A,Math.min((m+1)*A,e.size)));const h=w.slice().reverse(),E=new Array,z=g(F,n==null?void 0:n.onProgress,"uploadItem"),L=async()=>{for(;h.length!==0;){const m=w.length-h.length,P=h.pop(),T=new FormData,H=z.simulate(m,ps(P.size));try{T.append("f","json"),T.append("file",P),T.append("partId",`${m}`);const{data:_}=await f(B,{timeout:0,body:T,responseType:"json",method:"post"});if(u(n),!_.success)throw new Error("Part upload failed")}finally{H.remove()}}};for(let m=0;m<ys&&h.length!==0;++m)E.push(L());await Promise.all(E);const M=y(o,"commit"),{data:D}=await f(M,{query:{f:"json",parts:w.map((m,P)=>P).join(",")},responseType:"json",method:"post"});if(u(n),!D.success)throw new Error("Commit failed");return D.item}catch(r){if(o!=null){const i=y(o,"delete");await f(i,{query:{f:"json"},responseType:"json",method:"post"})}throw r}}function ws(e){return e.replaceAll("/","_").replaceAll("\\","_")}async function Ms(e,t,s){var o;const a=e.length;if(!a)return(o=s==null?void 0:s.onProgress)==null||o.call(s,1),[];const n=g(a,s==null?void 0:s.onProgress,"uploadAssets");return Promise.all(e.map((r,i)=>hs(r,t,{...s,onProgress:n.makeOnProgress(i)})))}async function hs(e,{layer:t,ongoingUploads:s},a){var r;const n=s.get(e);if(n)return n;if(!qs(t))throw new as;if(Ps(e,t))return(r=a==null?void 0:a.onProgress)==null||r.call(a,1),e;const o=Ts(e,t,a);s.set(e,o);try{await o}finally{s.delete(e)}return e}function Ps(e,t){const{parsedUrl:s}=t;return s!=null&&e.metadata.externalSources.some(a=>ss(a,s))}async function Ts(e,t,s){const{metadata:a}=e,{displaySource:n}=a,o=v(n==null?void 0:n.source,t),r=!!o,i=a.externalSources.length>0,c=r?As(o,t,s):i?bs(e,t,s):js(e,t,s),p=await c;return u(s),e.addExternalSources([p]),e}async function As(e,t,s){return{source:await O(e,t,s),original:!0}}async function bs(e,t,s){const a=C(t),{externalSources:n}=e.metadata,o=Es(n,t);if(!o)throw new ns;const r=g(b.uploadConvertibleSource,s==null?void 0:s.onProgress,"uploadConvertibleSource"),i=await O(o,t,{onProgress:r.makeOnProgress("uploadEditSource")});e.addExternalSources([{source:i,original:!0}]);const c=o.reduce((l,{asset:d})=>d instanceof File?l+d.size:l,0),p=r.simulate("serviceAssetsToGlb",ms(c));try{return{source:await Is(i,t,a)}}finally{p.remove()}}async function js(e,t,s){const a=g(b.uploadLocalMesh,s==null?void 0:s.onProgress,"uploadLocalMesh"),n=Fs(e,t,{...s,onProgress:a.makeOnProgress("meshToAssetBlob")});return{source:await q([n],t,{...s,onProgress:a.makeOnProgress("uploadAssetBlobs")}),extent:e.extent.clone(),original:!0}}async function Fs(e,t,s){const a=C(t),n=await e.load(s),o=await n.toBinaryGLTF({origin:n.origin,signal:s==null?void 0:s.signal,ignoreLocalTransform:!0});return u(s),{blob:new Blob([o],{type:"model/gltf-binary"}),assetName:`${J()}.glb`,assetType:a}}function Es(e,t){for(const s of e){const a=v(s.source,t);if(a)return a}return null}function v(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:a}}=t,n=ts(e),o=new Array;let r=!1;for(let i=0;i<n.length;++i){const c=Ds(n[i],s);if(!c)return null;a.includes(c.assetType)&&(r=!0),o.push(c)}return r?o:null}function Ds(e,t){const s=es(e,t);return s?{asset:e,assetType:s}:null}async function O(e,t,s){return q(e.map(a=>Ns(a,s)),t,s)}async function q(e,t,s){const a=g(b.uploadAssetBlobs,s==null?void 0:s.onProgress,"uploadAssetBlobs"),n=await Us(e,t,{...s,onProgress:a.makeOnProgress("prepareAssetItems")});u(s);const o=n.map(({item:i})=>i),{uploadResults:r}=await $s(o,t,{...s,onProgress:a.makeOnProgress("uploadAssetItems")});return u(s),e.map((i,c)=>xs(n[c],r[c],t))}async function Ns(e,t){const{asset:s,assetType:a}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:a};const n=await s.toBlob(t);return u(t),{blob:n,assetName:s.assetName,assetType:a}}async function Ss(e,t,s){const{blob:a,assetType:n,assetName:o}=e;let r=null;try{const i=await gs({data:a,name:o},t.url,s);u(s),r={assetType:n,assetUploadId:i.itemID}}catch(i){K(i),Cs().warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!r){const i=await Q(a);if(u(s),!i.isBase64)throw new ls;r={assetType:n,assetData:i.data}}if(!r)throw new us;return{item:r,assetName:o}}function Us(e,t,s){const a=g(e.length,s==null?void 0:s.onProgress,"prepareAssetItems");return Promise.all(e.map(async(n,o)=>{const r=Ss(await n,t,{...s,onProgress:a.makeOnProgress(o)});return u(s),r}))}async function $s(e,t,s){const a=fs(s==null?void 0:s.onProgress);try{const n=await f(y(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(u(s),n.data.uploadResults.length!==e.length)throw new os(e.length,n.data.uploadResults.length);return n.data}finally{a.remove()}}function xs(e,t,s){const{success:a}=t;if(!a){const{error:p}=t;throw new rs(e.assetName,p)}const{assetHash:n}=t,{assetName:o,item:{assetType:r}}=e,{infoFor3D:{supportedFormats:i}}=s,c=V(r,i);if(!c)throw new x(r);return new U(o,c,[new $(`${s.parsedUrl.path}/assets/${n}`,n)])}async function Is(e,t,s){var p;const a=e.map(({assetName:l,parts:d})=>({assetName:l,assetHash:d[0].partHash})),n=(p=t.capabilities)==null?void 0:p.operations.supportsAsyncConvert3D,o={f:"json",assets:JSON.stringify(a),transportType:"esriTransportTypeUrl",targetFormat:s,async:n},r=y(t.parsedUrl.path,"convert3D");let i;try{i=(await(n?Os:vs)(r,{query:o,responseType:"json",timeout:0})).data}catch{throw new is}const{supportedFormats:c}=t.infoFor3D;return i.assets.map(l=>{const d=S(l.contentType,c);if(!d)throw new x(d);return new U(l.assetName,l.contentType,[new $(l.assetURL,l.assetHash)])})}function vs(e,t){return f(e,t)}async function Os(e,t){const s=(await f(e,t)).data.statusUrl;for(;;){const a=(await f(s,{query:{f:"json"},responseType:"json"})).data;switch(a.status){case"Completed":return f(a.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(a.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await W(Rs)}}function qs(e){return!!e.infoFor3D&&!!e.url}function C(e){const{infoFor3D:t}=e,s=S("model/gltf-binary",t.supportedFormats)??X("glb",t.supportedFormats);if(!s)throw new cs;return s}function Cs(){return Y.getLogger("esri.layers.graphics.sources.support.uploadAssets")}const Rs=Z(1e3);export{Ms as uploadAssets};
