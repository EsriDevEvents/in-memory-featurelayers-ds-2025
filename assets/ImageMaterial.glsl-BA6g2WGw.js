import{y as I}from"./BufferView-_0HdWB6j.js";import{c as O,o as u,q as y,r as f}from"./Matrix4PassUniform-B-NXMru_.js";import{e as P}from"./basicInterfaces-wONHx_SN.js";import{o as b,u as S,r as A,d as C,A as w}from"./OutputHighlight.glsl-Bs_35Qno.js";import{u as x}from"./debugFlags-CfrzpJ7g.js";import{o as D,a as N,P as R,c as V,u as L,g as l,e as M,x as F,i as j,r as U,j as z,k as B,a0 as G,l as W,s as k,a1 as q,a2 as H,a3 as Q,ag as J,m as K,E as g,ah as X}from"./DefaultTechniqueConfiguration-C28-5KBi.js";import{s as Y}from"./Util-CQaYQWOS.js";import{e as p}from"./VertexAttribute-BnAa5VW0.js";import{f as Z}from"./DefaultLayouts-CvcU3NmP.js";import{e as tt}from"./ColorMaterial.glsl-D5JrE5f2.js";import{_ as et,j as i}from"./index-Dv-JqQDv.js";import{o as c}from"./interfaces-B8ge7Jg9.js";import{r as o}from"./ShaderTechniqueConfiguration-D3UbJ2mX.js";import{R as E}from"./enums-BlUEVwJR.js";import{s as rt,S as st,h as at,o as it,_ as ot}from"./renderState-yUi34s5A.js";import"./mat4f64-Dk4dwAN8.js";import"./BindType-BmZEZMMh.js";import"./mat3f64-BBpwCtoL.js";import"./vec2-DGogPjh1.js";import"./vec2f64-Diu2Kaa8.js";function T(r){const t=new D,{vertex:e,fragment:s}=t;return N(e,r),t.include(b,r),t.attributes.add(p.POSITION,"vec3"),t.attributes.add(p.UV0,"vec2"),r.perspectiveInterpolation&&t.attributes.add(p.PERSPECTIVEDIVIDE,"float"),t.varyings.add("vpos","vec3"),r.multipassEnabled&&t.varyings.add("depth","float"),e.code.add(c`
    void main(void) {
      vpos = position;
      ${r.multipassEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      vTexCoord = uv0;
      gl_Position = transformPosition(proj, view, vpos);

      ${r.perspectiveInterpolation?"gl_Position *= perspectiveDivide;":""}
    }
  `),t.include(R,r),t.include(V,r),s.uniforms.add(new L("tex",n=>n.texture),new O("opacity",n=>n.opacity)),t.varyings.add("vTexCoord","vec2"),r.transparencyPassType===l.ColorAlpha&&(t.outputs.add("fragColor","vec4",0),t.outputs.add("fragAlpha","float",1)),s.include(M),s.code.add(c`
    void main() {
      discardBySlice(vpos);
      ${r.multipassEnabled?"terrainDepthTest(depth);":""}
      fragColor = texture(tex, vTexCoord) * opacity;

      if (fragColor.a < ${c.float(F)}) {
        discard;
      }

      fragColor = highlightSlice(fragColor, vpos);
      ${r.transparencyPassType===l.ColorAlpha?c`
              fragColor = premultiplyAlpha(fragColor);
              fragAlpha = fragColor.a;`:""}
      ${r.output===u.ObjectAndLayerIdColor?c`
              fragColor = vec4(0,0,0,1);`:""}
    }
    `),t}const nt=Object.freeze(Object.defineProperty({__proto__:null,build:T},Symbol.toStringTag,{value:"Module"}));class _ extends U{initializeProgram(t){return new z(t.rctx,_.shader.get().build(this.configuration),$)}_setPipelineState(t,e){const s=this.configuration,n=t===l.NONE,d=t===l.FrontFace;return st({blending:s.output===u.Color&&s.transparent?n?pt:B(t):null,culling:at(s.cullFace),depthTest:{func:G(t)},depthWrite:n?s.writeDepth?it:null:W(t),drawBuffers:k(t),colorWrite:ot,stencilWrite:s.hasOccludees?q:null,stencilTest:s.hasOccludees?e?H:Q:null,polygonOffset:n||d?null:J(s.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._setPipelineState(this.configuration.transparencyPassType,!0),this._setPipelineState(this.configuration.transparencyPassType,!1)}getPipeline(t){return t?this._occludeePipelineState:super.getPipeline()}}_.shader=new j(nt,()=>et(()=>Promise.resolve().then(()=>dt),void 0,import.meta.url));const pt=rt(E.ONE,E.ONE_MINUS_SRC_ALPHA);class a extends K{constructor(){super(...arguments),this.output=u.Color,this.cullFace=P.None,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=l.NONE,this.multipassEnabled=!1,this.cullAboveGround=!1,this.perspectiveInterpolation=!0}}i([o({count:u.COUNT})],a.prototype,"output",void 0),i([o({count:P.COUNT})],a.prototype,"cullFace",void 0),i([o()],a.prototype,"hasSlicePlane",void 0),i([o()],a.prototype,"transparent",void 0),i([o()],a.prototype,"enableOffset",void 0),i([o()],a.prototype,"writeDepth",void 0),i([o()],a.prototype,"hasOccludees",void 0),i([o({count:l.COUNT})],a.prototype,"transparencyPassType",void 0),i([o()],a.prototype,"multipassEnabled",void 0),i([o()],a.prototype,"cullAboveGround",void 0),i([o()],a.prototype,"perspectiveInterpolation",void 0),i([o({constValue:!1})],a.prototype,"occlusionPass",void 0);const $=new Map([[p.POSITION,0],[p.UV0,2],[p.PERSPECTIVEDIVIDE,3]]);let Nt=class extends tt{constructor(t){super(t,new ut),this.supportsEdges=!0,this.produces=new Map([[g.OPAQUE_MATERIAL,e=>y(e)||f(e)&&!this.parameters.transparent],[g.TRANSPARENT_MATERIAL,e=>f(e)&&this.parameters.transparent&&this.parameters.writeDepth],[g.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,e=>f(e)&&this.parameters.transparent&&!this.parameters.writeDepth],[g.DRAPED_MATERIAL,e=>f(e)||y(e)]]),this._vertexAttributeLocations=$,this._configuration=new a}getConfiguration(t,e){return this._configuration.output=t,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=e.transparencyPassType,this._configuration.enableOffset=e.camera.relativeElevation<X,this._configuration.multipassEnabled=e.multipassEnabled,this._configuration.cullAboveGround=e.multipassTerrain.cullAboveGround,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}createGLMaterial(t){return new lt(t)}createBufferWriter(){const t=Z.clone();return this.parameters.perspectiveInterpolation&&t.f32(p.PERSPECTIVEDIVIDE),new ct(t)}};class lt extends S{constructor(t){super({...t,...t.material.parameters})}_updateParameters(t){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.ensureTechnique(_,t)}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.hasOccludees&&(this._material.setParameters({hasOccludees:t.hasOccludees}),this._updateParameters(t))}beginSlot(t){return this._output===u.Color&&this._updateOccludeeState(t),this._updateParameters(t)}}class ct extends A{write(t,e,s,n,d){for(const h of this.vertexBufferLayout.fields.keys()){const m=s.attributes.get(h);if(m)if(h===p.PERSPECTIVEDIVIDE){Y(m.size===1);const v=n.getField(h,I);v&&C(m,v,d)}else w(h,m,t,e,n,d)}}}class ut extends x{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=P.None,this.hasOccludees=!1,this.opacity=1,this.textureId=null,this.initTextureTransparent=!0,this.perspectiveInterpolation=!1}}const dt=Object.freeze(Object.defineProperty({__proto__:null,build:T},Symbol.toStringTag,{value:"Module"}));export{Nt as g};
