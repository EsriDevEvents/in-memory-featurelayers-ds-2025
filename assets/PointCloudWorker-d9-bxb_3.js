import{ds as d,O as v,J as c,ci as $,dt as M}from"./index-Dv-JqQDv.js";import{O as g}from"./quat-B52zwwOM.js";import{e as y}from"./quatf64-BrpT0VRp.js";import{t as h,n as I}from"./vec3f32-Cw9Q6TO_.js";import{u as w,c as b,i as O,f as S}from"./PointCloudWorkerUtil-D7UjHueV.js";import{I as x}from"./orientedBoundingBox-BiAE_4Zn.js";import"./mat3f64-BBpwCtoL.js";import"./I3SBinaryReader-DZaX-yfP.js";import"./VertexAttribute-BnAa5VW0.js";import"./mat3-B7LiNcRs.js";import"./mat4f64-Dk4dwAN8.js";import"./spatialReferenceEllipsoidUtils-MFgRhPLs.js";import"./computeTranslationToOriginAndRotation-DBznw1xD.js";import"./plane-4BN6ZBDV.js";import"./vec2f64-Diu2Kaa8.js";import"./mathUtils-urfecwwD.js";import"./ViewingMode-Dodu7ZZk.js";class F{transform(t){const r=this._transform(t),a=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&a.push(r.pointIdFilterMap.buffer);for(const n of r.attributes)"buffer"in n.values&&d(n.values.buffer)&&n.values.buffer!==r.rgb.buffer&&a.push(n.values.buffer);return Promise.resolve({result:r,transferList:a})}_transform(t){const r=w(t.schema,t.geometryBuffer);let a=r.length/3,n=null;const f=new Array,o=b(t.primaryAttributeData,r,a);t.primaryAttributeData!=null&&o&&f.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:o});const u=b(t.modulationAttributeData,r,a);t.modulationAttributeData!=null&&u&&f.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:u});let e=O(t.rendererInfo,o,u,a);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const l=t.filterAttributesData.filter(v).map(i=>{const D=b(i,r,a),p={attributeInfo:i.attributeInfo,values:D};return f.push(p),p});n=new Uint32Array(a),a=S(r,e,n,t.filterInfo,l)}for(const l of t.userAttributesData){const i=b(l,r,a);f.push({attributeInfo:l.attributeInfo,values:i})}3*a<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*a))),z(r,a,t.elevationOffset);const m=J(r,a,x.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:m,rgb:e,attributes:f,pointIdFilterMap:n}}}function J(s,t,r,a,n){if(!$(s,a,0,s,n,0,t))throw new Error("Can't reproject");const f=h(r.center),o=I(),u=I(),e=h(r.halfSize);g(A,r.quaternion);const m=new Float32Array(3*t);for(let l=0;l<t;l++){let i=3*l;o[0]=s[i]-f[0],o[1]=s[i+1]-f[1],o[2]=s[i+2]-f[2],M(u,o,A),e[0]=Math.max(e[0],Math.abs(u[0])),e[1]=Math.max(e[1],Math.abs(u[1])),e[2]=Math.max(e[2],Math.abs(u[2])),m[i++]=o[0],m[i++]=o[1],m[i]=o[2]}return r.halfSize=e,m}function z(s,t,r){if(r!==0)for(let a=0;a<t;a++)s[3*a+2]+=r}const A=y();function V(){return new F}export{V as default};
